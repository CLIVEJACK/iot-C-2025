# iot- c2025
Iot 개발자 c언어의 리포지토리

## 1일차 

### c의 기초
- c언어는 대표적인 절차 지향적인 언어이다 
    - 함수생성
        함수 선언 > 함수 정의 > 함수 호출 
    - 변수 
        - 데이터를 담아서 쓰기위해 사용
        - R_Value: 값이라고 하며 리터럴(상수)라고 하며 변하지 않는 값이다
        - L_Value: 변수명이라고 하며 변하는 수이다
    - 자료형
        - int, char, double, float, ... 
        - signed char 는 음수포함 -128 ~ 127 이고 0은 양수에 속하지만 음수도 양수도 아니다
        - unsigned char는 0 ~ 255 양수만 취급한다
        - const는 변수명의 이름을 가지고 변경시키는걸 못하게한다 포인터로 하면 잘바뀐다
        - sizeof는 자료형의 크기를 알수있다
    - 화면 입출력 
        - printf() 
        - scanf()를 쓸때에 오류방지를 위해 "#define _CRT_SECURE_NO_WARNINGS" 를 작성
    - 문자열 포맷팅
        - %s, %d, %lf, %u....
    - 연산자 
        - 사칙연산: +,-,*,/,%

## 2일차

### c언어 기초 계속
- 연산자 
    - 산술연산자 [C언어](./Day2/oper2.c)
        - ++n : 전위 연산자 1을 증가하고 n을 실행
        - n++ : 후위 연산자 n을 실행되고 1을 증가
    - 논리연산자 [C언어](./Day2/oper.c)
        - &&: && 기준으로 좌항과 우항의 조건이 만족하면 참(1)출력 거짓(0)을 출력 
        - ||: || 기준으로 좌항또는 우항이 의조건이 하나라도 만족하면 참(1)을출력 것짓이면 거짓(0)을출력
        - ! : 부정연산자 Ex)참을거짓으로 거짓을 참으로
    - 대입연산자 
        - = : =을 기준으로 우항을 좌행에 대입한다
    - 비트연산자 [C언어](./Day2/oper2.c)
        - & : 비트단위 AND 연산
        - | : 비트단위 OR 연산
        - ~ : 비트단위 NOT 연산
        - ^ : 비트단위 XOR 연산
        - << : 왼쪽으로 비트 이동
        - ,>> : 오른쪽으로 비트 이동
    - 삼항 연산자 [C언어](./Day2/oper2.c)
        조건 ? 참일때의 값 : 거짓일때의 값;

- 제어문
    - 선택제어문
        - if : if문은 조건문이 범위 [C언어](./Day2/if.c)
        ``` 
        if (조건문){
            조건문이 만족하면 실행되는 문
         }
        else if (또다른 조건문){
            또다른 조건문이 맞으면 실행
         }
        else{
            나머지 조건문
         }
         
        ```
        - switch [C언어](./Day2/swithc.c)
        ```
        switch (조건문) {    
	    case 조건:
		    조건이 맞으면 실행;
		    break;	
	    case 또다른조건:
		    또다른조건이 맞으면 실행;
		    break;
	    case 또또다른조건:
		    또또다른조건이 맞으면 실행;
		    break;
	    default: 이것도 저것도 아님
		    나머지들 실행;
		    break;
	    }  

        ```
        - switch문은 조건식이 달라도 break문을 만날때까지 전체 실행  
        - switch문은 조건식이 정확할때씀
    - 반복제어문 
        - for [C언어](./Day2/for.c)
        ```
            for(초기식; 조건식; 증감식) {
          조건식과 증감식이 계속해서 실행 
             }
        ```
        - while [C언어](./Day2/while.c)
        ```
        while(조건식){  
         조건식이 만족할때 까지 실행
        }
        ```
    - 함수 [C언어](./Day2/func4.c)
    ```
    반환형 함수이름 (매개변수)
    int sum (int a, int b)       //함수선언
         
    int main()
    {
      sum();            // 함수 호출
      return 0;
    }
         
    int sum(int a, inb){        // 함수 정의
      int res = a + b;
      return res;
     }


    ```

## 3일차 
- 배열 [C언어](./Day3/array.c)
    ```
    반환형 art[배열갯수] = {배열갯수만큼 넣을 수 있음}
    ```
    - 동일한 자료형을 연속적으로 사용하는 것
    - 인덱스를 사용함
    - 배열 : 인덱스로 연결되어있다  
        - 장점 : 편하게 불러옴                            
        - 단점 : 수정이 어렵다
    - 배열의 주소는 첫번째방 주소와 같다 
    - 각가의 방을 가리키는 배열은 **연산자**
    - int로 배열을 저장하면 값의 개수만큼 크기를 지정하지만 char값으로 하는경우에는 +1을 해줘야한다
    - 배열에서의 카피는 `strcpy(str, str2);`로 가능하다 str2의 값을 str로 카피해라
- 연결 리스트
- 포인터 [C언어](./Day3/pointer.c)
    - 포인터는 주소이다 
    - 포인터 변수 선언 `int *p`로 포인터변수 선언
    - *는 그냥 표시이며 *p는 p의 저장된값을 가리킨다  
    - 주소의 크기와 포인터크기는 같다 [C언어](./Day3/pointer2.c)
- 포인터 변수
    - 주소를 저장할수 있는 변수 [C언어](./Day3/pointer.c)
    - 두값을 바꾸는 알고리즘. 임시변수[C언어](./Day3/pointer3.c)
- swap [C언어](./Day3/swap.c)

- 배열과 포인트 [C언어](./Day3/pointer5.c)
    - (pa + 1)에서  주소에 +1은 4바이트가 차이가 난다
    - 포인터연산식.[ ] == *( ) 은 같다 

- 포인터 문제 풀어보기 [C언어](./Day3/pointer6.c)
- const [C언어](./Day3/pointer7.c)
    - 데이터 상수 : 포인터변수를 통한 데이터의 변경을 불허한다.
    - 포인터 상수 : 포인터변수가 가리키는 주소의 변경을 불허한다. 

- 문자 전용 함수 [C언어](./Day3/char.c) [C언어](./Day3/char2.c)
    - getchar: 수신> 한문자를 읽어오는 함수
    - putchar: 송신> 한문자를 출력하는 함수
    
- 대소문자 변환 [C언어](./Day3/char3.c)


## 4일차
- 문자열을 입력받아 출력 [C언어](./Day4/char4.c)

- 문자열  [C언어](./Day4/string.c)
    - Data 세그먼트
        - 힙: 사용자에게 할당된 메모리 영역 
        - satck: 지역변수, 매개변수
        - Data: 전역변수, static
        - Rod: 문자열 상수, 리터럴 
    - code 세그먼트
        - 함수 
        - 제어문

    - 문자열 상수는 주소이다 [C언어](./Day4/string2.c)
        - 문자열 상수는 변경불가능
        - 포인터로 변경이 가능하다
    - 문자열 전용 프린트 함수
        - gets : 공백을 포함하여 출력 [C언어](./Day4/string3.c)
        - fgerts : 공백을 포함하여 출력 `fgets(str, sizeof(str), stdin)`stdin사용 [C언어](./Day4/string3.c)
            - 입력스트림: stdin 표준 입력버퍼 
        - puts : 자동 개행  [C언어](./Day4/string4.c)
        - fputs : 개행 안됨 `fputs(str, stdout)` stdout사용 [C언어](./Day4/string4.c)
            - 입력스트림: stdin 표준 입력버퍼
        - 문자열 길이 계산 [C언어](./Day4/strlen.c)
            - 선언 `strlen(배열)`
        - 문자열 복사 함수 [C언어](./Day4/strcpy.c)
            - 선언 `strcpy(복사, 원본)`  오른쪽의 값을 왼쪽에 저장함
- 배열
    - 2차원 배열 초기화  [C언어](./Day4/array.c)
        - `int ary[행][열] = {}` 로 선언
        - 행열에서 값이 비면 0으로 자동으로 채운다
        - 행은 지정하지 않아도 되지만 열은 무조건 지정해줘야한다
    - 2차원 char 배열  [C언어](./Day4/array2.c)
        - 각행의 문자열을 저장한다 
        
- 배열 포인터 [C언어](./Day4/arraypointer.c)
    - 배열을 가리키는 포인터 이다 
    - 배열의 값을 나타낸다
    - `int(* pary) = ary` 로 선언한다
   
- 이중포인터 [C언어](./Day4/dpointer.c) [C언어](./Day4/dpointer2.c) 
    - `*`은 포인터 선언 과 해당 포인터가 가리키는 원래 값을 가져온다
    - `&`은 그 변수가 가리키던 주소의 위치를 받는다
    - 포인터를 지목하는 포인터 

- 변수
    - 전역변수: 프로그램 전체 [C언어](./Day4/strcpy.c)
    - 지역변수: 블록안에서만 사용, 매개변수, 자동변수[C언어](./Day4/strcpy.c)
    - 정적변수: 전역 + 지역 [C언어](./Day4/value2.c)


## 5일차
